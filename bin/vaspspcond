#! /usr/bin/env ruby


require 'thor'
require 'malge'
require 'vasputils'
require 'pp'
require "optparse"

##一点計算の条件検討を扱う。

### Command template
class Vaspspcond < Thor

  # dir = template dir
  desc 'vary dir options', 'Generate vasp directories of varied condition.'
  option :encut, desc: "ENCUT values"
  option :ka,    desc: "ka values"
  option :kb,    desc: "kb values"
  option :kc,    desc: "kc values"
  option :kab,   desc: "kab values"
  option :kbc,   desc: "kbc values"
  option :kca,   desc: "kca values"
  option :kabc,  desc: "kabc values"
  def vary(* args)
    template_dir = args.shift
    spc = VaspUtils::SinglePointCondition.new
    spc.generate_condition_dirs(template_dir, options)
  end

  desc "analyze core_dir", "Analyze error with conditions."
  option :encut, desc: "ENCUT value"
  option :ka,    desc: "ka"
  option :kb,    desc: "kb"
  option :kc,    desc: "kc"
  option :kab,   desc: "kab; ka and kb"
  option :kbc,   desc: "kbc; kb and kc"
  option :kca,   desc: "kca; kc and ka"
  option :kabc,  desc: "kabc; ka, kb, and kc"
  def analyze
    #type convert options
    encut = options[:encut].to_f if options[:encut]
    kmesh = {}
    [:ka,  :kb,  :kc,  :kab, :kbc, :kca, :kabc].each do |key|
      kmesh[key] = options[key].to_i if options[key]
    end

    vaspdirs = []
    Dir.glob("*").each do |dir|
      begin
        vaspdirs << VaspUtils::VaspDir.new(dir)
      rescue VaspUtils::VaspDir::InitializeError
        next
      end
    end

    data = vaspdirs.map do |dir|
      {
        :encut => dir.incar.data["ENCUT"].to_f,
        :ka => dir.kpoints.mesh[0].to_i,
        :kb => dir.kpoints.mesh[1].to_i,
        :kc => dir.kpoints.mesh[2].to_i,
        :toten => dir.outcar[:totens][-1].to_f,
      }
    end

    func = Malge::MultiVariableFunction.new(data)

    if kmesh[:kabc]
      func.unite_axes!([:ka, :kb, :kc], :kabc)
    elsif kmesh[:kab]
      func.unite_axes!([:ka, :kb], :kab)
    elsif kmesh[:kbc]
      func.unite_axes!([:kb, :kc], :kbc)
    elsif kmesh[:kca]
      func.unite_axes!([:kc, :ka], :kca)
    end

    # ENCUT analysis
    puts "#### Fitting on ENCUT"
    encut_func = func.abstract(kmesh)
    #pp encut_func
    #pp encut_func.data_pairs(:encut, :toten)
    kmesh.keys.each {|k| encut_func.delete_axis! k}
    eff = Malge::ErrorFittedFunction::AExpBX.new(
      encut_func.data_pairs(:encut, :toten).uniq
    )
    #pp eff
    puts eff.summary

    # k-mesh analysis
    #pp func
    kmesh.each do |key, val|
      puts "#### Fitting on #{key}"
      #pp key, val
      conds = Marshal.load(Marshal.dump(kmesh))
      conds.delete key
      conds[:encut] = encut
      k_func = func.abstract(conds)
      eff = Malge::ErrorFittedFunction::AXInv2.new(
        k_func.data_pairs(key, :toten).uniq
      )
      puts eff.summary
    end
  end

end

Vaspspcond.start(ARGV)
