#! /usr/bin/env ruby
# coding: utf-8

require "pp"
require "find"                  # 再帰的下降モジュール
require "rubygems"
require "vasputils"
#gem "malge"
#require "malge"
#require "vasputils/erroranalyzer.rb"


#require "optparse"
### option analysis
#OPTIONS = {}
#op = OptionParser.new
#op.on("-b val", "--bak=val", "descriptionB"){|v| OPTIONS[:bak] = v}
#op.on("-a"    , "--all"    , "All fitting are done."){    OPTIONS[:all] = true}
#op.parse!(ARGV)

unless ARGV.size == 0
  puts "USAGE: This script analyze subdirs of current dir; not use argument."
  exit
end

dir = ENV['PWD']
eac = VaspUtils::ErrorAnalyzer::Collector.new(dir)

puts "All converged data:"
eac.converged_dirs.each do |dir|
  printf("  k-mesh = [%2d, %2d, %2d], ENCUT = %7.1f, TOTEN = %10.5f\n",
    *dir.kpoints[:mesh], dir.incar["ENCUT"], dir.outcar[:totens][-1])
end
puts

def show_analysis(fitter)
  coefficients = fitter.fit
  #printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
  printf("    a_0 = %10.4f, a_1 = %10.4f\n", *coefficients)
  puts "    Expected errors:"
  #pp fitter.expected_errors
  fitter.expected_errors.each do |pair|
    print "      #{pair[0].to_s}, #{pair[1].to_s}\n"
  end
  puts
end

puts "Fitting to |E_t - a_0| = a_1 / n_k"
eac.encuts.each do |encut|
  data_pairs = eac.kmesh_toten_pairs_of_encut(encut)
  ktf = VaspUtils::ErrorAnalyzer::KmeshTotenFitter.new(data_pairs)
  printf( "  Fixed ENCUT of %4d:\n", encut)
  show_analysis(ktf)
end

puts "Fitting to |E_t - a_0| = a_1 / E_c"
eac.kmeshes.each do |kmesh|
  data_pairs = eac.encut_toten_pairs_of_kmesh(kmesh)
  etf = VaspUtils::ErrorAnalyzer::EncutTotenFitter1.new(data_pairs)
  printf( "  Fixed k-mesh of [%2d, %2d, %2d]:\n", *kmesh)
  show_analysis(etf)
end

puts "Fitting to |E_t - a_0| = a_1 / E_c^{3/2}"
eac.kmeshes.each do |kmesh|
  data_pairs = eac.encut_toten_pairs_of_kmesh(kmesh)
  etf = VaspUtils::ErrorAnalyzer::EncutTotenFitter32.new(data_pairs)
  printf( "  Fixed k-mesh of [%2d, %2d, %2d]:\n", *kmesh)
  show_analysis(etf)
end

puts "Fitting to |E_t - E_last| = a e^{bx}"
eac.kmeshes.each do |kmesh|
  HERE

  data_pairs = eac.encut_toten_pairs_of_kmesh(kmesh)
  etf = VaspUtils::ErrorAnalyzer::EncutTotenFitter32.new(data_pairs)
  printf( "  Fixed k-mesh of [%2d, %2d, %2d]:\n", *kmesh)
  show_analysis(etf)
end




#ファイルの中身が try?? の最後が最新の計算結果であることを前提とする。
#result みたいな名前にしてると動かない。
#どうしても別の名前にするのなら symlink にしておくことを勧める。
#
#今後としては、サブディレクトリ以下の全ての OUTCAR を含む計算ディレクトリを列挙し、Iter 1 で終わっていたら収束した計算の条件であるとする。

#geomopt で finished になっていることを確認
#latest_dir を取得。
#その計算条件の kpoints, encut, toten を取得。

#まとめて表という形にはしない。
#  結局のところ、どの条件を揃えてどの条件を振るかだから
#  多次元関数になる。
#  Array などにまとめなおす意味があまりない。
#
#k点、ENCUT 以外は全て一緒であることを仮定する。
#
#k 点のリストを取得。
#  本来なら対称性に合わせて ka, kb, kc を別々に扱える必要がある。
#
#[400, 500, 600].each do |encut|
#  計算全部から encut にマッチするのを抽出し、
#  [1.0/k 点数, TOTEN] の Array を作成。
#  これを配列にした二重配列にして least_square_1st_degree にかける。
#  出力する。
#end
#
#vaspdirs = []
#Find.find(".") do |path|      # シムリンクには効かないので注意
#  next unless FileTest.directory? path
#  begin
#    vd = VaspUtils::VaspDir.new path
#  rescue VaspUtils::VaspDir::InitializeError
#    next
#  end
#
#  next unless vd.finished?
#  next unless vd.outcar[:ionic_steps] == 1
#  vaspdirs << vd
#end
#
##vaspdirs.each do |vd|
##  puts "Converged calculations:"
##  encut = vd.incar["ENCUT"].to_i
##  kmesh = vd.kpoints[:mesh].inject(1){|i, p| i * p}
##  toten = vd.outcar[:totens][-1]
##  printf("  %10.4f, %10.4f, %10.4f\n\n", encut, kmesh, toten)
##end
#
#puts "Fixed ENCUT and varying k-mesh(n_k): (|y - a_0| = a_1 / n_k)"
#[400, 500, 600].each do |encut|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    next unless vd.incar["ENCUT"].to_i == encut
#    n = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    toten = vd.outcar[:totens][-1]
#    data_pairs << [1.0/n.to_f, toten]
#  end
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#end
#
#puts
#puts "Fixed k-mesh and varying Encut(E): (|y - a_0| = a_1 / E)"
#[1, 8, 64].each do |tgt|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    n_k = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    next unless n_k == tgt 
#
#    toten = vd.outcar[:totens][-1]
#    encut = vd.incar["ENCUT"].to_f
#    data_pairs << [1.0/(encut.to_f       ), toten]
#  end
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#  printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
#end
#
#puts
#puts "Fixed k-mesh and varying Encut(E): (|y -a_0| = a_1 / E^(3/2))"
#[1, 8, 64].each do |tgt|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    n_k = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    next unless n_k == tgt 
#
#    toten = vd.outcar[:totens][-1]
#    encut = vd.incar["ENCUT"].to_f
#    #data_pairs << [1.0/(encut.to_f       ), toten]
#    data_pairs << [1.0/(encut.to_f ** 1.5), toten]
#    #data_pairs << [ Math::exp(- encut.to_f/400), toten]
#  end
#  #pp data_pairs
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#  printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
#  puts
#end
#
#puts "This script is not completely made."
#
