#! /usr/bin/env ruby
# coding: utf-8

require "pp"
require "find"                  # 再帰的下降モジュール
require "vasputils.rb"
require "rubygems"
#gem "malge"
#require "malge"
require "vasputils/erroranalyzer.rb"


unless ARGV.size == 0
  puts "USAGE: This script analyze subdirs of current dir; not use argument."
  exit
end

dir = ENV['PWD']

def show_analysis(fitter)
  coefficients = ktf.fit
  #printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
  printf("    a_0 = %10.4f, a_1 = %10.4f\n", *coefficients)
end

eac = ErrorAnalyzer::Collector.new(dir)
eac.encuts.each do |encut|
  data_pairs = eac.kmesh_toten_pairs_of_encut(encut)
  ktf = ErrorAnalyzer::KmeshTotenFitter.new(data_pairs)
  printf( "  ENCUT = %4d:", encut)
  show_analysis(ktf)
end

eac.kmeshes.each do |kmesh|
  data_pairs = eac.encut_toten_pairs_of_kmesh(kmesh)
  ktf = ErrorAnalyzer::KmeshTotenFitter.new(data_pairs)
  printf( "  k-mesh = %3d:", tgt)
  show_analysis(ktf)
end


#ファイルの中身が try?? の最後が最新の計算結果であることを前提とする。
#result みたいな名前にしてると動かない。
#どうしても別の名前にするのなら symlink にしておくことを勧める。
#
#今後としては、サブディレクトリ以下の全ての OUTCAR を含む計算ディレクトリを列挙し、Iter 1 で終わっていたら収束した計算の条件であるとする。

#geomopt で finished になっていることを確認
#latest_dir を取得。
#その計算条件の kpoints, encut, toten を取得。

#まとめて表という形にはしない。
#  結局のところ、どの条件を揃えてどの条件を振るかだから
#  多次元関数になる。
#  Array などにまとめなおす意味があまりない。
#
#k点、ENCUT 以外は全て一緒であることを仮定する。
#
#k 点のリストを取得。
#  本来なら対称性に合わせて ka, kb, kc を別々に扱える必要がある。
#
#[400, 500, 600].each do |encut|
#  計算全部から encut にマッチするのを抽出し、
#  [1.0/k 点数, TOTEN] の Array を作成。
#  これを配列にした二重配列にして least_square_1st_degree にかける。
#  出力する。
#end
#
#vaspdirs = []
#Find.find(".") do |path|      # シムリンクには効かないので注意
#  next unless FileTest.directory? path
#  begin
#    vd = VaspUtils::VaspDir.new path
#  rescue VaspUtils::VaspDir::InitializeError
#    next
#  end
#
#  next unless vd.finished?
#  next unless vd.outcar[:ionic_steps] == 1
#  vaspdirs << vd
#end
#
##vaspdirs.each do |vd|
##  puts "Converged calculations:"
##  encut = vd.incar["ENCUT"].to_i
##  kmesh = vd.kpoints[:mesh].inject(1){|i, p| i * p}
##  toten = vd.outcar[:totens][-1]
##  printf("  %10.4f, %10.4f, %10.4f\n\n", encut, kmesh, toten)
##end
#
#puts "Fixed ENCUT and varying k-mesh(n_k): (|y - a_0| = a_1 / n_k)"
#[400, 500, 600].each do |encut|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    next unless vd.incar["ENCUT"].to_i == encut
#    n = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    toten = vd.outcar[:totens][-1]
#    data_pairs << [1.0/n.to_f, toten]
#  end
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#end
#
#puts
#puts "Fixed k-mesh and varying Encut(E): (|y - a_0| = a_1 / E)"
#[1, 8, 64].each do |tgt|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    n_k = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    next unless n_k == tgt 
#
#    toten = vd.outcar[:totens][-1]
#    encut = vd.incar["ENCUT"].to_f
#    data_pairs << [1.0/(encut.to_f       ), toten]
#  end
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#  printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
#end
#
#puts
#puts "Fixed k-mesh and varying Encut(E): (|y -a_0| = a_1 / E^(3/2))"
#[1, 8, 64].each do |tgt|
#  data_pairs = []
#  vaspdirs.each do |vd|
#    n_k = vd.kpoints[:mesh].inject(1){|i, p| i * p}
#    next unless n_k == tgt 
#
#    toten = vd.outcar[:totens][-1]
#    encut = vd.incar["ENCUT"].to_f
#    #data_pairs << [1.0/(encut.to_f       ), toten]
#    data_pairs << [1.0/(encut.to_f ** 1.5), toten]
#    #data_pairs << [ Math::exp(- encut.to_f/400), toten]
#  end
#  #pp data_pairs
#  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
#  printf("    a_0 = %10.4f, a_1 = %10.4f\n", coefficients[0], coefficients[1])
#  puts
#end
#
#puts "This script is not completely made."
#
