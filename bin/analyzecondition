#! /usr/bin/env ruby
# coding: utf-8

require "pp"
require "find"                  # 再帰的下降モジュール
require "vasputils.rb"
require "rubygems"
gem "malge"
require "malge"

#ファイルの中身が try?? の最後が最新の計算結果であることを前提とする。
#result みたいな名前にしてると動かない。
#どうしても別の名前にするのなら symlink にしておくことを勧める。
#
#今後としては、サブディレクトリ以下の全ての OUTCAR を含む計算ディレクトリを列挙し、Iter 1 で終わっていたら収束した計算の条件であるとする。

#geomopt で finished になっていることを確認
#latest_dir を取得。
#その計算条件の kpoints, encut, toten を取得。

#まとめて表という形にはしない。
#  結局のところ、どの条件を揃えてどの条件を振るかだから
#  多次元関数になる。
#  Array などにまとめなおす意味があまりない。
#
#k点、ENCUT 以外は全て一緒であることを仮定する。
#
#k 点のリストを取得。
#  本来なら対称性に合わせて ka, kb, kc を別々に扱える必要がある。
#
#[400, 500, 600].each do |encut|
#  計算全部から encut にマッチするのを抽出し、
#  [1.0/k 点数, TOTEN] の Array を作成。
#  これを配列にした二重配列にして least_square_1st_degree にかける。
#  出力する。
#end
#
#[1, 8, 64].each do |n_k|
#  encut と同じようにやる。
#end

vaspdirs = []
Find.find(".") do |path|      # シムリンクには効かないので注意
  next unless FileTest.directory? path
  begin
    vd = VaspUtils::VaspDir.new path
  rescue VaspUtils::VaspDir::InitializeError
    next
  end

  next unless vd.finished?
  next unless vd.outcar[:ionic_steps] == 1
  vaspdirs << vd
end

vaspdirs.each do |vd|
  encut = vd.incar["ENCUT"].to_i
  kmesh = vd.kpoints[:mesh].inject(1){|i, p| i * p}
  toten = vd.outcar[:totens][-1]
  printf("%10.3f, %10.3f, %10.3f\n", encut, kmesh, toten)
end

puts "Fixed ENCUT and varying k-mesh(n_k): (y = a_1 / n_k + a_0)"
[400, 500, 600].each do |encut|
  puts "  ENCUT = #{encut}"
  data_pairs = []
  vaspdirs.each do |vd|
    #pp vd.incar["ENCUT"]
    next unless vd.incar["ENCUT"].to_i == encut
    n = vd.kpoints[:mesh].inject(1){|i, p| i * p}
    toten = vd.outcar[:totens][-1]
    data_pairs << [1.0/n.to_f, toten]
  end
  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
  #pp coefficients
  print "    "
  printf("a_0 = %10.3f, ", coefficients[0])
  printf("a_1 = %10.3f", coefficients[1])
  puts
end

puts "Fixed k-mesh and varying Encut(E): (y = a_1 / E + a_0)"
[1, 8, 64].each do |tgt|
  puts "  k-mesh = #{tgt}"
  data_pairs = []
  vaspdirs.each do |vd|
    n_k = vd.kpoints[:mesh].inject(1){|i, p| i * p}
    next unless n_k == tgt 

    toten = vd.outcar[:totens][-1]
    #pp toten.to_f
    #data_pairs << [1.0/(toten.to_f ** 1.5), toten]
    data_pairs << [1.0/(toten.to_f), toten]
  end
  pp data_pairs
  coefficients = Malge::LeastSquare.least_square_1st_degree(data_pairs)
  print "    "
  printf("a_0 = %10.3f, ", coefficients[0])
  printf("a_1 = %10.3f", coefficients[1])
  puts
end
