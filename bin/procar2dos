#! /usr/bin/env ruby
# coding: utf-8

#
# procar2dos.rb :  write gnuplot type pdos data using PROCAR
# Atsushi Togo
# Time-stamp: <2006-05-25 21:41:31 togo>
# $Id: procar2dos.rb 405 2006-05-25 12:57:12Z  $

#require '~/tanaka-share/trunk/ruby/parseProcar.rb'
#require '~/tanaka-share/trunk/ruby/cBroadning.rb'
#require 'tanakalab/ParseProcar.rb'
#require 'tanakalab/cBroadning.rb'
#require "getopts"
require "vasputils"
require "optparse"
require "pp"

## option analysis
OPTIONS = {}
op = OptionParser.new
op.banner = <<HERE
usage: procar2dos.rb [OPTION] [PROCAR_file]
    default value of PROCAR_file is 'PROCAR'
HERE
#    -i [NUMBER]  solo ion number  like 1
#    -s ["NUMBER, NUMBER..."] sum up multi-numbers of ions like "1..3 5"
#    --all    sum all ions
#    -f [FERMI ENERGY]
#    -c       whether include occupancy or not
#    --f-orb   consider f orbital
#    --sigma  [SIGMA] set standard deviation for broadning (default 0.1)
#    --check  just show number of ions and number of eigenvalues
#    -t [TICK] (default 0.01)
#    -p       show precise orbitals, but heavy
#    --total  total DOS
#
#    -l [WEIGHT FILE]  lap over PROCAR's
op.on('-i num', '--ion=num', 'solo ion number  like 1'){ |v|
  OPTIONS[:ion] = v
}
op.on("-s 'num num...'", '--sum-ions=nums', "sum up multi-numbers of ions like '1..3 5'"){ |v|
  OPTIONS[:sum_ions] = v
}
op.on('--all', 'sum all ions'){
  OPTIONS[:all] = true
}
op.on('-f energy', '--fermi=energy', 'FERMI ENERGY'){ |v|
  OPTIONS[:fermi] = v
}
op.on('-c', '--occupancy', 'Use occupancy, instead of number of orbitals.'){
  OPTIONS[:occupancy] = true
}
op.on('--f-orb', 'consider f orbital'){
  OPTIONS[:f_orb] = true
}
op.on('--sigma=val', 'set standard deviation for broadning (default 0.1)'){ |v|
  OPTIONS[:sigma] = v
}
op.on('--check', 'just show number of ions and number of eigenvalues'){
  OPTIONS[:check] = true
}
#op.on('-l WEIGHT_FILE', "lap over PROCAR's"){ |v|
#  OPTIONS[:weight_file] = v
#}
op.on('-t TICK', '--tick=num', 'tick value (default 0.01)'){ |v|
  OPTIONS[:tick] = v
}
op.on('-p', '--precise', 'show precise orbitals, but heavy'){
  OPTIONS[:precise] = true
}
op.on('--total', 'total DOS'){
  OPTIONS[:total] = true
}
op.parse!(ARGV)

procar_file = ARGV[0] || 'PROCAR'


fermi_level = OPTIONS[:fermi].to_f
tick = 0.01
tick = OPTIONS[:tick].to_f if OPTIONS[:tick]
sigma = 0.1
sigma = OPTIONS[:sigma].to_f if OPTIONS[:sigma]


#  if OPTIONS[:f_orb]
#    @f_orbital = true
#  else
#    @f_orbital = false
#  end
#
#  if OPTIONS[:weight_file]
#    @projection = Array.new
#    layover
#  else
#    @projection = eachProcar(ARGV.shift)
#  end
#end

def gaussFunction(deviation,sigma)
  1/sigma/Math.sqrt(2*Math::PI)*Math.exp(-deviation**2/(2*sigma**2))
end

def broadning(array, dE, sigma = 0.1)
  dos = Array.new
  (((array[-1][0] - array[0][0]) / dE).to_i + 2).times do |i|
    sumArray = Array.new(array[0].size-1, 0)
    energy = array[0][0] + i*dE
    STDERR.print("#{energy}\n")
    array.each do |state|

      gauss = gaussFunction(energy-state[0], sigma)
      sumArray.size.times do |j|
        sumArray[j] += state[j+1] * gauss
      end
    end
    dos << [energy]+sumArray
  end
  dos
end

procar = VaspUtils::Procar.load_file(procar_file)

#'1 3..5' => [1,3,4,5]
def collect_ions(option)
  results = Array.new
  option.strip.gsub(/,/," ").gsub(/-/,"..").split(/\s+/).each do |x|
    if /\.\./ =~ x || /-/ =~ x
      i = x.split(/\.\./)
      i[0].to_i.upto(i[1].to_i) {|j| results << j}
    else
      results << x.to_i
    end
  end
  ions = ""
  results.each {|i| ions << sprintf("%d,", i)}
  STDERR.print("#{ions.chop}\n")
  results
end
#pp collect_ions('1 3..5')
#exit


if OPTIONS[:total]
  energy = procar.energies
  occupancy = procar.occupancies
  weight = procar.weights
  states = Array.new
  energy.size.times do |i|
    tmparray = Array.new
    energy[0].size.times do |j|
      tmparray << [energy[i][j], 2*weight[i], occupancy[i][j]*weight[i]]
    end
    states += tmparray
  end
  projection = states.sort

  dos = broadning(projection, tick, sigma)

  # for index 0
  printf("#%12s  %12s\n", "eigenvalue", "total", "total with occ")
  dos.each do |a|
    printf("%13.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2])
  end
  print "\n\n"
  # for index 1, impluse
  printf("#%-12s  %-12s  %-12s\n", "eigenvalue", "states", "with occ")
  projection.each do |x|
    printf("%13.8f  %12.8f  %12.8f\n", x[0], x[1], x[2])
  end
  exit
end

# うまく動かない。
#if OPTIONS[:precise]
#  dos = broadning(projection, tick, sigma )
#  pp projection
#  if @f_orbital
#    printf("#%12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s\n",
#           "eigenvalue", "s", "py", "pz", "px", "dxy", "dyz", "dz2", "dxz", "dx2", "f-3", "f-2", "f-1", "f0", "f1", "f2", "f3", "raw total")
#    dos.each do |a|
#      printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n",
#             a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17])
#    end
#  else
#    printf("#%12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s\n",
#           "eigenvalue", "s", "py", "pz", "px", "dxy", "dyz", "dz2", "dxz", "dx2", "raw total")
#    dos.each do |a|
#      #pp a; exit
#      printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n",
#             a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])
#    end
#  end
#  exit
#end

## not total nor precise
#dos = PostProcessProcar.new(procar.states, procar.weights, procar.energies, procar.occupancies)
case
when OPTIONS[:all]
  states = procar.get_all(OPTIONS[:occupancy])
when OPTIONS[:sum_ions]
  ionNumbers = collect_ions(OPTIONS[:sum_ions])
  states = dos.getSum_ions(ionNumbers, OPTIONS[:occupancy])
when OPTIONS[:ion]
  ionNumbers = [OPTIONS[:ion].to_i]
  states = dos.getSum_ions(ionNumbers, OPTIONS[:occupancy])
else
  STDERR.print("-s, -i, or --all options are required.\n")
  exit(1)
end
projection = states

states = Array.new
projection.each do |a|
  p = a[2] + a[3] + a[4]
  d = a[5] + a[6] + a[7] + a[8] + a[9]
  f = a[10] + a[11] + a[12] + a[13] + a[14] + a[15] + a[16] if @f_orbital
  if @f_orbital
    states << [a[0], a[1], p, d, f, a[10]] if @f_orbital
  else
    states << [a[0], a[1], p, d, a[10]]
  end
end
dos = broadning(states)

if @f_orbital
  printf("#%12s  %12s  %12s  %12s  %12s  %12s\n", "eigenvalue", "s", "p", "d", "f", "raw total")
  dos.getDos.each do |a|
    printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5])
  end
else
  printf("#%12s  %12s  %12s  %12s  %12s\n", "eigenvalue", "s", "p", "d", "raw total")
  dos.getDos.each do |a|
    printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2], a[3], a[4])
  end
end

  

exit

class Procar2dos

  def printGnuplot
    if OPTIONS[:total]
    else
      if OPTIONS[:precise]
        #printPhaseGnuplot
      else
        #printPartialGnuplot
      end
    end
  end

  private

  def eachProcar(filename)
    procar = VaspUtils::Procar.load_file(filename)
    if OPTIONS[:total]
    else
      states = eachProcarPartial(procar)
    end
    states
  end

#  def layover
#    weightArray = Array.new
#    sumWeight = 0
#
#    File.open(OPTIONS[:weight_file]) do |file|   # read weight file
#      while line = file.gets
#        next if (weight = line.strip.to_f) == 0
#        weightArray << weight
#        sumWeight += weight
#      end
#    end
#
#    weightArray.each do |weight|
#      filename = ARGV.shift
#      STDERR.print("#{filename}    weight:#{weight}     sum of weight:#{sumWeight}\n")
#      array = eachProcar(filename)
#      array.size.times do |i|
#        (1..array[0].size-1).each {|j| array[i][j] = array[i][j] * weight / sumWeight}
#      end
#      projection += array
#    end
#    @projection.sort!
#  end


end



if OPTIONS[:check]
  procar = VaspUtils::Procar.load_file(procar_file)
  num_ions = procar.num_ions
  num_energies = procar.energies.size
  print "number of ions: #{num_ions}\nnumber of eigenvalues: #{num_energies}\n"
  exit(1)
end

dos = Procar2dos.new
dos.printGnuplot
