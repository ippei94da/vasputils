#! /usr/bin/env ruby
# coding: utf-8

#
# procar2dos.rb :  write gnuplot type pdos data using PROCAR
# Atsushi Togo
# Time-stamp: <2006-05-25 21:41:31 togo>
# $Id: procar2dos.rb 405 2006-05-25 12:57:12Z  $
# Modified by Ippei Kishida.
# Last-modified: 2016/02/03 13:53:50.


USAGE = <<HERE
usage: procar2dos.rb [OPTION] [ion_indices]
  Sum up orbitals of ions of 'ion_indices' and output gnuplot style data.
  'ion_indices' is started from 1 as in PROCAR.
  If 'ion_indices' is empty, use all ions.

HERE


require "vasputils"
require "optparse"
require "pp"

## option analysis
options = {}
op = OptionParser.new
op.banner = USAGE
##op.on("-i 'num num...'", '--ion-indices=nums', "sum up selected ions like '1..3 5'"){ |v|
#  options[:select_ions] = v
#}
#op.on('--f-orb', 'consider f orbital'){
#  options[:f_orb] = true
#}
#op.on('-l WEIGHT_FILE', "lap over PROCAR's"){ |v|
#  options[:weight_file] = v
#}
op.on('--check', 'Just show number of ions and number of eigenvalues'){
  options[:check] = true
}
op.on('-f energy', '--fermi=energy', Float, 'FERMI ENERGY'){ |v|
  options[:fermi] = v
}
op.on('-s val', '--sigma=val', Float, 'Set standard deviation for broadning (required, example --sigma=0.1).)'){ |v|
  options[:sigma] = v
}
op.on('-t TICK', '--tick=num', Float, 'Tick value (default 0.01)'){ |v|
  options[:tick] = v
}
op.on('-p', '--precise', 'Show precise orbitals. E.g., py, pz, px'){
  options[:precise] = true
}
op.on('-o', '--occupancy', 'Use occupancy, in spite of 2 electrons in a orbital.'){
  options[:occupancy] = true
}
op.on('-P file', '--PROCAR=file', 'Indicate PROCAR file. Default is "PROCAR"'){ |v|
  options[:procar] = v
}
op.on('--min=energy', Float, 'Minimum value of energy range.'){ |v|
  options[:min_energy] = v
}
op.on('--max=energy', Float, 'Maximum value of energy range.'){ |v|
  options[:max_energy] = v
}
#op.on('--total', 'total DOS'){
#  options[:total] = true
#}
op.parse!(ARGV)

procar_file = options[:procar] || 'PROCAR'
unless File.exist? procar_file
  puts "Not found #{procar_file}"
  exit
end
procar = VaspUtils::Procar.load_file(procar_file)

if options[:check]
  procar = VaspUtils::Procar.load_file(procar_file)
  #pp procar;exit
  puts "number of spins:       #{procar.num_spins}"
  puts "number of kpoints:     #{procar.num_kpoints}"
  puts "number of bands:       #{procar.num_bands}"
  puts "number of ions:        #{procar.num_ions}"
  #puts "number of eigenvalues: #{procar.energies.size}"
  exit(1)
end


options[:fermi] ||= 0.0
options[:tick]  ||= 0.01
#options[:sigma] ||= 0.1
#pp options; exit

unless options[:sigma]
  puts '--sigma option must be indicated.'
  exit
end
if options[:sigma] == 0.0
  puts '--sigma cannot be indicated to be zero'.
  exit
end


ion_indices = ARGV.map{|i| i.to_i}
ion_indices = (1..(procar.num_ions)).to_a if ARGV.empty?
if ion_indices.include?( 0 )
  puts "Ion index must be indicated by PROCAR style, starting from 1."
  puts USAGE
  exit
end
ion_indices.map! {|i| i.to_i}

options.delete(:procar)
options.delete(:check)

dos = procar.density_of_states(ion_indices, options)

## output
### labels
labels = procar.dos_labels(options)
print "#"
labels.size.times { |i| printf(" %12s", labels[i]) }
puts

### data
dos.each do |values|
  print ' '
  values.each do |value|
    printf(" %12.8f", value)
  end
  puts
end

exit

class Procar2dos

  def printGnuplot
    if options[:total]
    else
      if options[:precise]
        #printPhaseGnuplot
      else
        #printPartialGnuplot
      end
    end
  end

  private

  def eachProcar(filename)
    procar = VaspUtils::Procar.load_file(filename)
    if options[:total]
    else
      states = eachProcarPartial(procar)
    end
    states
  end

#  def layover
#    weightArray = Array.new
#    sumWeight = 0
#
#    File.open(options[:weight_file]) do |file|   # read weight file
#      while line = file.gets
#        next if (weight = line.strip.to_f) == 0
#        weightArray << weight
#        sumWeight += weight
#      end
#    end
#
#    weightArray.each do |weight|
#      filename = ARGV.shift
#      STDERR.print("#{filename}    weight:#{weight}     sum of weight:#{sumWeight}\n")
#      array = eachProcar(filename)
#      array.size.times do |i|
#        (1..array[0].size-1).each {|j| array[i][j] = array[i][j] * weight / sumWeight}
#      end
#      projection += array
#    end
#    @projection.sort!
#  end


end


dos = Procar2dos.new
dos.printGnuplot
