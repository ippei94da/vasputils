#! /usr/bin/env ruby
# coding: utf-8

#
# procar2dos.rb :  write gnuplot type pdos data using PROCAR
# Atsushi Togo
# Time-stamp: <2006-05-25 21:41:31 togo>
# $Id: procar2dos.rb 405 2006-05-25 12:57:12Z  $
# Modified by Ippei Kishida.
# Last-modified: 2016/02/09 12:32:11.

#スピンごとに正負を逆にするか、同じ軸にするかのオプションと関連。
#スピンごとにどのようい表示すべきか。。
#建増しがひどく、すっきりかけていない。
#occupancy オプションで対応するのがよいきもしてきた。
#Procar.dos_for_spin で occupancy に対処しようとしたが、ここでは既に occupancy の情報が
#失われているので、やるならもっと上流でやる必要がある。

USAGE = <<HERE
usage: procar2dos.rb [OPTION] [ion_indices]
  Sum up orbitals of ions of 'ion_indices' and output gnuplot style data.
  'ion_indices' is started from 1 as in PROCAR.
  If 'ion_indices' is empty, use all ions.

HERE

require "vasputils"
require "optparse"
require "pp"
require "gnuplot"

## option analysis
options = {}
op = OptionParser.new
op.banner = USAGE
##op.on("-i 'num num...'", '--ion-indices=nums', "sum up selected ions like '1..3 5'"){ |v|
#  options[:select_ions] = v
#}
#op.on('--f-orb', 'consider f orbital'){
#  options[:f_orb] = true
#}
#op.on('-l WEIGHT_FILE', "lap over PROCAR's"){ |v|
#  options[:weight_file] = v
#}
op.on('--check', 'Just show number of ions and number of eigenvalues'){
  options[:check] = true
}
op.on('-f energy', '--fermi=energy', Float, "Fermi energy. (E' = E-E_Fermi, Positive value shifts DOS to right-hand.)"){ |v|
  options[:fermi] = v
}
op.on('-s val', '--sigma=val', Float,
      'Set standard deviation for broadning (required, example --sigma=0.1)'
      #'When --sigma=0.0 is set, show peak information without broadening.'
     ){ |v|
        options[:sigma] = v
      }
op.on('-t TICK', '--tick=num', Float, 'Tick value (default 0.01)'){ |v|
  options[:tick] = v
}
op.on('-d', '--downspin-minus', 'Multiply (-1) to down spin.'){
  options[:down] = true
}
op.on('-p', '--precise', 'Show precise orbitals. E.g., py, pz, px'){
  options[:precise] = true
}
op.on('-o', '--occupancy', 'Use occupancy(0<=x<=1), in spite of 2 electrons in a orbital.'){
  options[:occupancy] = true
}
op.on('-P file', '--PROCAR=file', 'Indicate PROCAR file. Default is "PROCAR"'){ |v|
  options[:procar] = v
}
op.on('--min=energy', Float, 'Minimum value of energy range.'){ |v|
  options[:min_energy] = v
}
op.on('--max=energy', Float, 'Maximum value of energy range.'){ |v|
  options[:max_energy] = v
}
#op.on('--total', 'total DOS'){
#  options[:total] = true
#}
op.parse!(ARGV)

procar_file = options[:procar] || 'PROCAR'
unless File.exist? procar_file
  puts "Not found #{procar_file}"
  exit
end
procar = VaspUtils::Procar.load_file(procar_file)

if options[:check]
  puts "number of spins:       #{procar.num_spins}"
  puts "number of kpoints:     #{procar.num_kpoints}"
  puts "number of bands:       #{procar.num_bands}"
  puts "number of ions:        #{procar.num_ions}"
  #puts "number of eigenvalues: #{procar.energies.size}"
  exit(1)
end

ion_indices = ARGV.map{|i| i.to_i}
ion_indices = (1..(procar.num_ions)).to_a if ARGV.empty?
if ion_indices.include?( 0 )
  puts "Ion index must be indicated by PROCAR style, starting from 1."
  puts USAGE
  exit
end
ion_indices.map! {|i| i.to_i}


options[:fermi] ||= 0.0
options[:tick]  ||= 0.01


unless options[:sigma]
  puts '--sigma option must be indicated.'
  exit
end
if options[:sigma] == 0.0
  puts '--sigma cannot be indicated to be zero'.
  exit
end


options.delete(:procar)
options.delete(:check)

#p options
dos = procar.density_of_states(ion_indices, options)


## output
### labels
print "#"
procar.dos_labels(options).each {|label| printf(" %12s", label) }
puts

### data
dos[:energies].size.times do |i|
  printf(" %12f", dos[:energies][i])
  dos[:orbitals][i].each do |orb|
    printf(" %12f", orb)
  end
  puts
end
#
#  print ' '
#  values.each do |value|
#    printf(" %12.8f", value)
#  end
#  puts
#end

exit

#  def layover
#    weightArray = Array.new
#    sumWeight = 0
#
#    File.open(options[:weight_file]) do |file|   # read weight file
#      while line = file.gets
#        next if (weight = line.strip.to_f) == 0
#        weightArray << weight
#        sumWeight += weight
#      end
#    end
#
#    weightArray.each do |weight|
#      filename = ARGV.shift
#      STDERR.print("#{filename}    weight:#{weight}     sum of weight:#{sumWeight}\n")
#      array = eachProcar(filename)
#      array.size.times do |i|
#        (1..array[0].size-1).each {|j| array[i][j] = array[i][j] * weight / sumWeight}
#      end
#      projection += array
#    end
#    @projection.sort!
#  end
