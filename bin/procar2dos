#! /usr/bin/env ruby
# coding: utf-8

#
# procar2dos.rb :  write gnuplot type pdos data using PROCAR
# Atsushi Togo
# Time-stamp: <2006-05-25 21:41:31 togo>
# $Id: procar2dos.rb 405 2006-05-25 12:57:12Z  $
# Modified by Ippei Kishida.
# Last-modified: 2016/01/31 16:04:40.

USAGE = <<HERE
usage: procar2dos.rb [OPTION] [ion_indices]
    If 'ion_indices' is empty, use all ions.
HERE


require "vasputils"
require "optparse"
require "pp"

## option analysis
options = {}
op = OptionParser.new
op.banner = USAGE
#    -s ["NUMBER, NUMBER..."] sum up multi-numbers of ions like "1..3 5"
#    -f [FERMI ENERGY]
#    -c       whether include occupancy or not
#    --f-orb   consider f orbital
#    --sigma  [SIGMA] set standard deviation for broadning (default 0.1)
#    --check  just show number of ions and number of eigenvalues
#    -t [TICK] (default 0.01)
#    -p       show precise orbitals, but heavy
#    --total  total DOS
#
#    -l [WEIGHT FILE]  lap over PROCAR's
op.on("-s 'num num...'", '--select-ions=nums', "sum up selected ions like '1..3 5'"){ |v|
  options[:select_ions] = v
}
op.on('-f energy', '--fermi=energy', 'FERMI ENERGY'){ |v|
  options[:fermi] = v
}
op.on('--f-orb', 'consider f orbital'){
  options[:f_orb] = true
}
op.on('--sigma=val', 'set standard deviation for broadning (default 0.1)'){ |v|
  options[:sigma] = v
}
op.on('--check', 'just show number of ions and number of eigenvalues'){
  options[:check] = true
}
#op.on('-l WEIGHT_FILE', "lap over PROCAR's"){ |v|
#  options[:weight_file] = v
#}
op.on('-t TICK', '--tick=num', 'tick value (default 0.01)'){ |v|
  options[:tick] = v
}
op.on('-p', '--precise', 'show precise orbitals, but heavy'){
  options[:precise] = true
}
op.on('-P file', '--PROCAR=file', 'Indicate PROCAR file. Default is "PROCAR"'){ |v|
  options[:procar] = v
}
op.on('--total', 'total DOS'){
  options[:total] = true
}
op.parse!(ARGV)

procar_file = options[:procar] || 'PROCAR'
fermi_level = options[:fermi].to_f
tick = 0.01
tick = options[:tick].to_f if options[:tick]
sigma = 0.1
sigma = options[:sigma].to_f if options[:sigma]

procar = VaspUtils::Procar.load_file(procar_file)

if options[:total]
  energies = procar.energies
  weights = procar.weights
  states = Array.new
  energies.size.times do |i|
    tmparray = Array.new
    energies[0].size.times do |j|
      tmparray << [energies[i][j], 2*weights[i], procar.occupancies[i][j]*weights[i]]
    end
    states += tmparray
  end
  projection = states.sort

  dos = broadning(projection, tick, sigma)

  # for index 0
  printf("#%12s  %12s  %12s\n", "eigenvalue", "total", "total with occ")
  dos.each do |a|
    printf("%13.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2])
  end
  print "\n\n"
  # for index 1, impluse
  printf("#%-12s  %-12s  %-12s\n", "eigenvalue", "states", "with occ")
  projection.each do |x|
    printf("%13.8f  %12.8f  %12.8f\n", x[0], x[1], x[2])
  end
  exit
end

# うまく動かない。
#if options[:precise]
#  dos = broadning(projection, tick, sigma )
#  pp projection
#  if @f_orbital
#    printf("#%12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s\n",
#           "eigenvalue", "s", "py", "pz", "px", "dxy", "dyz", "dz2", "dxz", "dx2", "f-3", "f-2", "f-1", "f0", "f1", "f2", "f3", "raw total")
#    dos.each do |a|
#      printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n",
#             a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17])
#    end
#  else
#    printf("#%12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s  %12s\n",
#           "eigenvalue", "s", "py", "pz", "px", "dxy", "dyz", "dz2", "dxz", "dx2", "raw total")
#    dos.each do |a|
#      #pp a; exit
#      printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n",
#             a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])
#    end
#  end
#  exit
#end

## not total nor precise
#dos = PostProcessProcar.new(procar.states, procar.weights, procar.energies, procar.occupancies)
#pp procar.get_all(options[:occupancy])
#exit
if options[:select_ions]
  ionNumbers = collect_ions(options[:select_ions])
  #states = procar.sum_ions(ionNumbers, options[:occupancy])
  states = procar.sum_ions(ionNumbers)
else
  states = procar.get_all
end
projection = states

states = Array.new
projection.each do |a|
  p = a[2] + a[3] + a[4]
  d = a[5] + a[6] + a[7] + a[8] + a[9]
  f = a[10] + a[11] + a[12] + a[13] + a[14] + a[15] + a[16] if @f_orbital
  if @f_orbital
    states << [a[0], a[1], p, d, f, a[10]] if @f_orbital
  else
    states << [a[0], a[1], p, d, a[10]]
  end
end
dos = broadning(states, tick, sigma)

if @f_orbital
  printf("#%12s  %12s  %12s  %12s  %12s  %12s\n", "eigenvalue", "s", "p", "d", "f", "raw total")
  dos.each do |a|
    printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2], a[3], a[4], a[5])
  end
else
  printf("#%12s  %12s  %12s  %12s  %12s\n", "eigenvalue", "s", "p", "d", "raw total")
  dos.each do |a|
    printf("%13.8f  %12.8f  %12.8f  %12.8f  %12.8f\n", a[0]-fermi_level, a[1], a[2], a[3], a[4])
  end
end


class Procar2dos

  def printGnuplot
    if options[:total]
    else
      if options[:precise]
        #printPhaseGnuplot
      else
        #printPartialGnuplot
      end
    end
  end

  private

  def eachProcar(filename)
    procar = VaspUtils::Procar.load_file(filename)
    if options[:total]
    else
      states = eachProcarPartial(procar)
    end
    states
  end

#  def layover
#    weightArray = Array.new
#    sumWeight = 0
#
#    File.open(options[:weight_file]) do |file|   # read weight file
#      while line = file.gets
#        next if (weight = line.strip.to_f) == 0
#        weightArray << weight
#        sumWeight += weight
#      end
#    end
#
#    weightArray.each do |weight|
#      filename = ARGV.shift
#      STDERR.print("#{filename}    weight:#{weight}     sum of weight:#{sumWeight}\n")
#      array = eachProcar(filename)
#      array.size.times do |i|
#        (1..array[0].size-1).each {|j| array[i][j] = array[i][j] * weight / sumWeight}
#      end
#      projection += array
#    end
#    @projection.sort!
#  end


end



if options[:check]
  procar = VaspUtils::Procar.load_file(procar_file)
  num_ions = procar.num_ions
  num_energies = procar.energies.size
  print "number of ions: #{num_ions}\nnumber of eigenvalues: #{num_energies}\n"
  exit(1)
end

dos = Procar2dos.new
dos.printGnuplot
